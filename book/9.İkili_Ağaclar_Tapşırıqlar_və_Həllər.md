# İkili ağaclar - tapşırıqlar və həllər

Bu fəsildə ikili ağaclarla bağlı tapşırıq və onların  həllərinə nəzər yetirəcik.
İlk öncə tapşırığın izahını daha sonra da kod parçasını göstərəcik.

## Tapşırıq - 1

*Şərt:*

İkili ağacda maximum elementi tapın.

*Həlli:*

Bir üsulumuz bu ola bilər ki, ilk öncə sol altağacda maximum elementi tapaq, daha sonra sol altağacda maximum elementi tapaq və onu root elementlə müqayisə edək. Gördüyünüz kimi, bu işi rekursiv üsulla həll edə bilərik.
> Qeyd: bütün kodlara baxmaq üçün [fesil9_problems_solutions.py](../Source_Code/python_kodlar/fesil9/fesil9_problems_solutions.py)

Kod nümunəmiz:

```python
    def find_max_recursive(self, node):
        if not node:
            return self.max_data

        if node.get_data() > self.max_data:
            self.max_data = node.get_data()
        
        self.find_max_recursive(node.left)
        self.find_max_recursive(node.right)

        return self.max_data
```

Bizim nümunə ağacımız üçün yuxarıdakı kod 14 qaytaracaq:

```python
tree = BinaryTree()
    arr = [8, 3, 1, 6, 4, 7, 10, 14, 13]
    for i in arr:
        tree.create_tree(i)
    
    print(tree.find_max_recursive(tree.root))
```

## Tapşırıq - 2

*Şərt:*

Rekursiyadan istifadə etmədən ağacdakı maximum elementi tapın.

*Həlli:*

`Level Order Traversal` metodundan(bax 8-ci fəsilə) istifadə etməklə, hər səviyyədə(level) elementləri Növbədən silərkən müqayisə apararaq, maximum elementi aşkarlaya bilərik.

Kod nümunəmiz:

```python
    def find_max_level_order_traversal(self, node):
        if node is not None:
            q = Queue()
            q.put(node) # root node-u daxil edirik.

            while not q.empty():
                node = q.get() # Dequeue FIFO
                # növbədən çıxartdıqdan sonra müqayisə edirik.
                if node.get_data() > self.max_data:
                    self.max_data = node.get_data()

                if node.left is not None:
                    q.put(node.left)

                if node.right is not None:
                    q.put(node.right)
        
        return self.max_data
```

## Tapşırıq - 3

*Şərt:*

Ikili ağacda verilmiş data-lı node-un olub-olmamasını yoxlamaq və yaxud ağacda element axtarmaq.

*Həlli:*

İlk ağıla gələn təbii üsul, root-dan başlamaq, öncə sol altağacda, daha sonra da sağ altağacda verilmiş elementi axtarmaqdır.

Rekursiv kod nümunəmiz:

```python
    def find_data_recursive(self, node, data):
        if node is None:
            return 0

        if node.get_data() == data:
            return 1
        elif data < node.get_data(): 
            return self.find_data_recursive(node.left, data)    
        else:
            return self.find_data_recursive(node.right, data)
```

Kodumuzu sınayaq:

```python
    tree = BinaryTree()
    arr = [8, 3, 1, 6, 4, 7, 10, 14, 13]
    for i in arr:
        tree.create_tree(i)
    print("find_max_recursive() -> ", end='')
    print(tree.find_max_recursive(tree.root))
    print("find_max_level_order_traversal() -> ", end='')
    print(tree.find_max_level_order_traversal(tree.root))
    print("find_data_recursive() search 88 -> ", end='')
    print(tree.find_data_recursive(tree.root, 88))
    print("find_data_recursive() search 14 -> ", end='')
    print(tree.find_data_recursive(tree.root, 14))
```

Nəticə:

```python
$ python3 fesil9_problems_solutions.py
find_max_recursive() -> 14
find_max_level_order_traversal() -> 14
find_data_recursive() search 88 -> 0
find_data_recursive() search 14 -> 1
```

## Tapşırıq - 4

*Şərt:*

Yuxarıdakı axtarışı iterativ üsulla edin.

*Həlli:*

Bu zaman ağıla gələn üsul budur ki, Level Order Traversal-dan istifadə edərək, hər level-də axtarış edək, yoxlayaq ki, verilmiş(axtarılan) data hansı node-dadır.

Kod nümunəmiz:

```python
    def find_data_level_order_traversal(self, node, data):
        if node is not None:
            q = Queue()
            q.put(node) # root node-u daxil edirik.

            while not q.empty():
                node = q.get() # Dequeue FIFO
                # növbədən çıxartdıqdan sonra yoxlayırıq.
                if node.get_data() == data:
                    return 1
                if node.left is not None:
                    q.put(node.left)

                if node.right is not None:
                    q.put(node.right)
        # 0 qayıdırsa, deməli data Ağacda yoxdur.            
        return 0
```

Nəticə:

```python
$ python3 fesil9_problems_solutions.py
find_max_recursive() -> 14
find_max_level_order_traversal() -> 14
find_data_recursive() search 88 -> 0
find_data_recursive() search 14 -> 1
find_data_level_order_traversal() search 88 -> 0
find_data_level_order_traversal() search 14 -> 1
```

## Tapşırıq - 5

*Şərt:*

İkili ağaca element daxil etməyin üsulunu yazın.

*Həll:*

Bu məqsədlə yenidən, Level Order Traversal üsulundan istifadə edə bilərik.
Belə ki, hər level(səviyyə)-də sağ və ya sol node-u olmayan node-u aşkarlayaraq, ora daxil edə bilərik.

Kod nümunəmiz:

```python
    def insert_in_binary_using_tree_level_order(self, node, data):
        new_node = Node(data)
        if node is None:
            node = new_node # Ağac boşdursa, yeni node-u root node edirik.
            return node
        
        q = Queue()
        q.put(node) # Root node-u növbəyə daxil edirik.

        while not q.empty():
            node = q.get() # Dequeue FIFO
            # növbədən çıxartdıqdan sonra yoxlayırıq.
            if node.get_data() == data:
                return "Already in tree"
            if node.left is not None:
                q.put(node.left)
            else:
                # Əgər hal-hazırkı node-un datasından kiçikdirsə
                if new_node.get_data() < node.get_data():
                    node.left = new_node
                    return "Inserted as left node"

            if node.right is not None:
                q.put(node.right)
            else:
                # Əgər hal-hazırkı node-un datasından böyükdürsə
                if new_node.get_data() > node.get_data():
                    node.right = new_node
                    return "Inserted as right node"
```

## Tapşırıq - 6

*Şərt:*

Ağacın ölçüsünü(elementlərinin sayını, node-ların sayını) tapın.

*Həlli:*

Rekursiv olaraq sağ və sol altağacları ziyarət etmək lazımdır. Son nəticənin də üstünə 1 gəlmək lazımdır(root node-u).

```python
    def find_tree_size_recursive(self, node):
        if node is None:
            return 0
        
        return self.find_tree_size_recursive(node.left) + self.find_tree_size_recursive(node.right) + 1
```

## Tapşırıq - 7

*Şərt:*

Ağacın ölçüsünü iterativ üsulla tapın(yuxarıdakı məsələni).

*Həlli:*

Yenə də Level Order Traversal edərək hər səviyyədəki node sayını hesablayırıq.

```python
    def find_tree_size_iterative(self, node):
        if node is None:
            return 0
        
        q = Queue()
        q.put(node) # Root node-u növbəyə daxil edirik.
        count = 0

        while not q.empty():
            node = q.get()
            count = count + 1
            if node.left is not None:
                q.put(node.left)
            if node.right is not None:
                q.put(node.right)

        return count
```

Nəticə:

```python
$ python3 fesil9_problems_solutions.py
find_max_recursive() -> 14
find_max_level_order_traversal() -> 14
find_data_recursive() search 88 -> 0
find_data_recursive() search 14 -> 1
find_data_level_order_traversal() search 88 -> 0
find_data_level_order_traversal() search 14 -> 1
insert_in_binary_using_tree_level_order(tree.root, 21) -> Inserted as right node
find_tree_size_recursive() -> 10
find_tree_size_iterative() -> 10
```

## Tapşırıq - 8

*Şərt:*

Level Order Traversal-ın elementləri əks(reverse) ardıcıllıqla çap edən növünü yazın.

*Həlli:*

Adi qaydada etdiyimiz Level Order Traversal zamanı, bir də köməkçi list-dən istifadə etsək, hər dəfə Queue-dən çıxartdığımız node-u həmin listə yığsaq son nəticədə bizdə Stack əmələ gələcək. Yəni faktiki olaraq, ən son gələni ən birinci çıxarda biləcik(LİFO). Bunu list-dən pop() edərək əldə edirik. Aşağıdakı kod parçacsına diqqət yetirək:

```python
def level_order_traversal_in_reverse(self, node):
        if node is None:
            return 0
        
        q = Queue()
        s = [] # LIFO üçün istifadə edəcəyimiz list
        q.put(node) # root node-u daxil edirik.

        while not q.empty():
            node = q.get() # Dequeue FIFO
            s.append(node.get_data()) # LIFO

            if node.left is not None:
                q.put(node.left)

            if node.right is not None:
                q.put(node.right)
        
        while(s):
            print(s.pop(), end=' ')
```

Nəticəmizdən də göründüyü kimi ağacın elementlərini tərsinə olaraq çıxara bildik:

```python
$ python3 fesil9_problems_solutions.py
find_max_recursive() -> 14
find_max_level_order_traversal() -> 14
find_data_recursive() search 88 -> 0
find_data_recursive() search 14 -> 1
find_data_level_order_traversal() search 88 -> 0
find_data_level_order_traversal() search 14 -> 1
insert_in_binary_using_tree_level_order(tree.root, 21) -> Inserted as right node
find_tree_size_recursive() -> 10
find_tree_size_iterative() -> 10
level_order_traversal_in_reverse() -> 13 7 4 21 14 6 1 10 3 8
```