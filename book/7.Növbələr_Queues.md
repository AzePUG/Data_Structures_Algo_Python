# Növbə(queue)

## 7.1 Növbə nədir?

Növbə də yığın kimi məlumatı saxlamaq üçün sadə data strukturudur.
Növbədə, datanın daxil olma ardıcıllığı önəmlidir.
Əslində, əsl həyatda növbədə gözləmək necədirsə, burda da elədir. Növbəyə ilk daxil olan, yəni növbədə birinci olan, xidmətdən də ilk istifadə edir.
Avtobusa birinci minir, bankda kassada manatını dollara birinci çevirir, dükanda dolu səbətini kassada ilk boşaldaraq, digər növbədəkilərin həsrət dolu baxışlarına tuş gəlir.

**Tərif**

Növbə elementlərin daxil olma ardıcıllığını saxlayan bir listdir. Bu listə element onun sonuna(rear) daxil edilir və onun əvvəlindən(front) silinir.
Dolayısı ilə, növbəyə ilk daxil edilən element, ilk də silinəcək(növbədən çıxacaq).
Buna həm də FİFO(First İn First Out) deyilir.

**Xüsusi terminlər**

Yığında olduğu kimi, bəzi xüsusi terminləri də burda qeyd etməliyik.
Elementin növbəyə daxil edilməsinə *EnQueue*, elementin növbədən silinməsinə isə *DeQueue* deyilir.
Boş növbədə *DeQueue* əməliyyatı *underflow*, dolu növbədə *EnQueue* isə *overflow* adlanır. 
Biz bu halları *exception* kimi qəbul edirik.

## 7.2 Növbə gündəlik həyatda?

Məntiq olaraq, biz növbə prinsipini o zaman yaradırıq və o zaman tələb edirik ki, gələnlərin ardıcıllıq haqqları qorunsun.
Yəni sadə olaraq, yuxudan daha tez duran, daha isti çörəyi ala bilir və yaxud, bankda növbədə ilk nömrəsini alan ilk olaraq, müştəri xidmətlərinin rahat qoltuğuna otura bilir.
Növbə mədəniyyəti də bu mənada, ilk gələn üstün olur anlayışını qorumaq üçün yaratdığımız məfhumdur. 
Bu prinsipi pozmağa cəhd edən şəxsə, haqlı etirazlar səslənir.
Dolayısı ilə, bizə növbə o zaman lazım olur ki, orada daxil olma ardıcıllığı əhəmiyyətlidir.
Gündəlik həyatımızı növbəsiz və növbəni müxtəlif üsullarla pozmağa çalışan insanlarsız təsəvvür etmək mümkün deyil.


## 7.3 Queue ADT(abstract data type)

Aşağıdakı əməliyyatlar, növbəni ADT edir. 
Növbə üçün daxil etmə və silmə əməliyyatları FİFO sxemini izləməlidir. 
Sadəlik üçün, biz elementlərin integer olduğunu qəbul edirik.

**Əsas növbə əməliyyatları**
* EnQueue(): Növbənin sonuna element daxil edir.
* DeQueue(): Növbənin əvvəlindən elementi silir və qaytarır.

**Köməkçi növbə əməliyyatları**
* Front(): Növbənin əvvəlindən elementi silmədən qaytarır.
* QueueSize(): Növbədə olan elementlərin sayını qaytarır.
* IsEmptyQueue(): Növbə boşdursa True, növbədə elementlər varsa False qaytarır.


## 7.4 Exceptions

Boş növbə üçün DeQueue əməliyyatı *Empty Queue Exception* verməlidir. 
Eyni zamanda, dolu bir növbə üçün EnQueue əməliyyatı *Full Queue Exception* verməlidir.


## 7.5 Növbələr harda istifadə oluna bilər?

**Birbaşa istifadə edən:**
* Əməliyyat sisteminin, bərabər prioritetli job scheduler-ini xatırlamaq mühüm məqamdır.
Bunu printer üzərində izah etmək daha uyğun olacaq. Belə ki, mən 5 fərqli sənədi çap etmək üçün əmr icra edirəm. Bu zaman printer ona daxil olan sənədlərin ardıcıllığını(bərabər prioritet) qoruyur.
Yəni ilk daxil olan sənəd, ilk də çap olunur.
* Multiprogramming. 
* Asinxron məlumat transferi(file İO, pipe, socket).
* Müştəri xidmətlərinin gözləmə prinsipini icra edən call center.

**Dolayı yolla istifadə edən:**
* Alqoritmlər üçün köməkçi data stukturu ola bilər.
* Digər data strukturlarının komponenti kimi iştirak edə bilər.


## 7.6 Növbələri necə yaradaq?

Biz növbəni bir çox üsuldan istifadə edərək yarada bilərik və onlardan bəziləri aşağıdakılardır:

* Dövri massivdən istifadə etməklə.(Dövri Növbə)
* Dinamik dövri massivdən istifadə etməklə.
* Əlaqəli listlərdən istifadə etməklə.

Lakin, ilk öncə yaxşı olardı ki, dövri olmayan massivlə növbə yaratmağın çatışmazlığına nəzər yetirək.
Bizim üçün növbə əməliyyatları aşağıdakı qaydada icra olunacaq:

* `FRONT` və `REAR` adlı 2 göstəricimiz(pointer) var. Müvafiq olaraq, massivin ilk və son elementlərini özlərində saxlayırlar.
* Növbəni yaradanda `FRONT` və `REAR`-ə -1 dəyər veririk.
* EnQueue əməliyyatı zamanı, `REAR`-ın dəyərini artırırıq.
* DeQueue əməliyyatı zaman, `FRONT`-un dəyərini artırırıq.
* EnQueue-dən qabaq, növbənin dolu olub-olmamağını yoxlayırıq.
* DeQueue-dən qabaq, növbənin boş olub-olmamağını yoxlayırıq.
* Birinci elementi enqueue edəndə, `FRONT`-u 0-a bərabər edirik.
* Ən sonuncu elementi dequeue etdikdən sonra isə `FRONT` və `REAR`-i yenidən -1 edirik.
   
Aşağıdakı şəkilə diqqət yetiririk(Mənbə: [Queue](https://www.programiz.com/dsa/queue))

![](../Source_Code/resources/fesil7/fesil7_array_queue.jpg)

Gördüyünüz kimi, yuxarıda sadaladığımız addımların hamısını icra etmiş oluruq.

Bu metodun ciddi çatışmazlığı var, aşağıdakı növbəti şəkildən də göründüyü kimi, bir neçə dequeu və enqueue əməliyyatlarından sonra,
massivin uzunluğu(həcmi) qısalır. 0 və 1-ci indexləri biz yalnız massivi yenidən inisializasiya etsək istifadə edə bilərik.

![](../Source_Code/resources/fesil7/fesil7_array_queue_2.jpg)

Məhz bu səbəbdəndir ki, dövri növbələr daha səmərəli hesab olunur.

**Dövri massivlə növbə yaratmaq**
*Bu necə işləyir?*
Dövri növbənin iş prinsipi, növbənin sonuna çatanda, yenidən başlamaqdır. 
Növbəyə element daxil etdikdə, `REAR`-i artırdığımızı bilirik. 
Növbənin sonuna çatdıqda yenidən başlamaq məqsədilə də modul bölmədən istifadə edirik.
Deyək ki, bizim növbəmizin(massivin) uzunluğu 5-dir.
Bu zaman `REAR`-i aşağıdakı qaydada artırırıq(unutmuruq ki, ilkin qiymət -1-dir).

```python
>>> (-1+1)%5
0
>>> (0+1)%5
1
>>> (1+1)%5
2
>>> (2+1)%5
3
>>> (3+1)%5
4
>>> (4+1)%5
0
```

Gördüyünüz kimi, massivin sonuna çatanda `REAR` 0-landı, yəni yenidən başlandı.
Bu da əslində dövri sözünün burdakı yerinin isbatıdır.
Element daxil etməyə davam edə bilərik, sözsüz əgər boş yer varsa.
Mənbə: [Circular Queue](https://www.programiz.com/dsa/circular-queue)

`if REAR + 1 == 5 (overflow!), REAR = (REAR + 1)%5 = 0 (start of queue)`

![](../Source_Code/resources/fesil7/fesil7_circular-increment.jpg) 


Yuxarıda dediyimiz, Növbə əməliyyatları eyni şəkildə burda da təkrarlanır lakin bəzi əlavələrimiz var.
Belə ki, Növbənin dolu olmasını yoxlamağın 2 yeni halını qeyd etməliyik:
* Hal 1: `FRONT=0` and `REAR=SIZE-1` -> adi hal, heç dequeue etmədən, yalnız element daxil etdikdə, limitə(size-a) çatırıq.
* Hal 2: `FRONT=REAR+1` -> Bu zaman növbə əvvəldən yenidən başlayır(circular increment), lakin yeni element daxil edilsə `REAR` necə deyərlər, `FRONT`-a bərabərləşir.
Bu da o deməkdir ki, növbə doludur.

Aşağıdakı şəkildə bu məsələ daha aydın görsənir:

![](../Source_Code/resources/fesil7/fesil7_circular_queue_program.jpg)

İndi isə yuxarıdakı addımları izləməklə kodumuzu yazaq:

```python
class CircularQueue:

    def __init__(self, limit=5):
        self.que = []
        self.limit = limit
        self.front = -1 # Ön
        self.rear = -1  # Arxa, son

    def is_full(self):
        if self.front == 0 and self.rear == (self.limit - 1):
            return True
        elif self.front == self.rear + 1:
            return True
        return False

    def is_empty(self):
        return self.front == -1

    def en_queue(self, data):
        if self.is_full():
            print("Növbə doludur...")
        else:
            if self.front == -1:
                self.front = 0
            # REAR-i artırırıq, irəli çəkirik.
            self.rear = (self.rear + 1) % self.limit
            self.que.append(data)
            print("EnQueue-dən sonra, növbə, ", self.que)
        print("FRONT -> ", self.front)
        print("REAR -> ", self.rear)

    def de_queue(self):
        if self.is_empty():
            print("Növbə boşdur...")
        else:
            # Silmirik, sadəcə geri qaytarırıq
            data = self.que[self.front]
            # Əgər bərabərdilərsə o zaman cəmi 1 elementi var, bu səbəbdən sildikdən sonra resetləyirik.
            if self.front == self.rear:
                self.front = -1
                self.rear = -1
            else:
                # FRONT-u artırırıq, irəli çəkirik.
                self.front = (self.front + 1) % self.limit

            print("Silinən element - ", data)
            print("FRONT -> ", self.front)
            print("REAR -> ", self.rear)

    def size(self):
        return len(self.que)
```

Kod kommentlərindən, fikrimcə məsələ daha da aydın olacaq.
İndi isə kodumuzu test edək:

```python
obj = CircularQueue(limit=5)
obj.en_queue(56)
obj.en_queue(44)
obj.en_queue(85)
obj.en_queue(66)
obj.en_queue(99)
obj.en_queue(111)
obj.de_queue()
obj.de_queue()
obj.en_queue(111)
obj.de_queue()
obj.de_queue()
obj.de_queue()
```

Nəticə:

```python
EnQueue-dən sonra, növbə,  [56]
FRONT ->  0
REAR ->  0
EnQueue-dən sonra, növbə,  [56, 44]
FRONT ->  0
REAR ->  1
EnQueue-dən sonra, növbə,  [56, 44, 85]
FRONT ->  0
REAR ->  2
EnQueue-dən sonra, növbə,  [56, 44, 85, 66]
FRONT ->  0
REAR ->  3
EnQueue-dən sonra, növbə,  [56, 44, 85, 66, 99]
FRONT ->  0
REAR ->  4
Növbə doludur...
FRONT ->  0
REAR ->  4
Silinən element -  56
FRONT ->  1
REAR ->  4
Silinən element -  44
FRONT ->  2
REAR ->  4
EnQueue-dən sonra, növbə,  [56, 44, 85, 66, 99, 111]
FRONT ->  2
REAR ->  0
Silinən element -  85
FRONT ->  3
REAR ->  0
Silinən element -  66
FRONT ->  4
REAR ->  0
Silinən element -  99
FRONT ->  0
REAR ->  0
```

